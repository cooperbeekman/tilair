<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Tilair</title>

<style>
  * {
    box-sizing: border-box;
  }

  body {
    margin: 0;
    padding: 0;
    background: #0a0a0a;
    display: flex;
    align-items: center;
    justify-content: center;
    height: 100vh;
    overflow: hidden;
  }

  /* CRT scanline effect */
  body::before {
    content: "";
    position: fixed;
    inset: 0;
    background: repeating-linear-gradient(
      0deg,
      rgba(0, 0, 0, 0.15) 0px,
      rgba(0, 0, 0, 0.15) 1px,
      transparent 1px,
      transparent 2px
    );
    pointer-events: none;
    z-index: 10;
  }

  /* Subtle CRT glow */
  body::after {
    content: "";
    position: fixed;
    inset: 0;
    background: radial-gradient(
      ellipse at center,
      transparent 0%,
      rgba(0, 0, 0, 0.3) 100%
    );
    pointer-events: none;
    z-index: 5;
  }

  .terminal {
    position: relative;
    width: 100%;
    max-width: 1200px;
    padding: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
    min-height: 200px;
  }

  .text-display {
    font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Fira Mono', 'Droid Sans Mono', 'Source Code Pro', 'Courier New', monospace;
    font-size: 72px;
    font-weight: 400;
    letter-spacing: 0.05em;
    color: #e0e0e0;
    text-align: center;
    text-shadow:
      0 0 10px rgba(255, 255, 255, 0.3),
      0 0 20px rgba(255, 255, 255, 0.1);
    white-space: nowrap;
  }

  .text-display .char {
    display: inline-block;
    min-width: 0.6em;
    transition: color 0.1s ease;
  }

  .text-display .char.scrambling {
    color: #606060;
  }

  .text-display .char.locked {
    color: #e0e0e0;
  }

  /* Blinking cursor */
  .cursor {
    display: inline-block;
    width: 0.6em;
    height: 1.1em;
    background: #e0e0e0;
    margin-left: 4px;
    vertical-align: text-bottom;
    animation: blink 1s step-end infinite;
  }

  @keyframes blink {
    0%, 50% { opacity: 1; }
    51%, 100% { opacity: 0; }
  }

  @media (max-width: 768px) {
    .text-display {
      font-size: 36px;
    }
  }

  @media (max-width: 480px) {
    .text-display {
      font-size: 24px;
    }
  }
</style>
</head>

<body>

<div class="terminal">
  <div class="text-display" id="display"></div>
</div>

<script>
  const display = document.getElementById('display');

  const words = [
    "...", "..", ".",
    "Tilair",
    "Is",
    "A",
    "Holding Company",
    "Venture Studio",
    "Puerto Rico",
    "Crypto",
    "AI",
    "Defense Tech",
    "cole@tilair.com"
  ];

  // ASCII characters for scramble effect
  const scrambleChars = '!@#$%^&*()_+-=[]{}|;:,.<>?/~0123456789';

  // Timing parameters
  const cycleSpeed = 30;      // How fast random chars cycle (ms)
  const decodeSpeed = 50;     // Time between each char locking (ms)
  const holdTime = 1000;      // How long to display decoded word (ms)
  const scrambleOutSpeed = 40; // Speed of scramble out effect (ms)

  let currentWordIndex = 0;
  let isAnimating = false;

  function getRandomChar() {
    return scrambleChars[Math.floor(Math.random() * scrambleChars.length)];
  }

  function createCharSpans(word) {
    display.innerHTML = '';
    const chars = [];

    for (let i = 0; i < word.length; i++) {
      const span = document.createElement('span');
      span.className = 'char scrambling';
      span.textContent = getRandomChar();
      span.dataset.target = word[i];
      span.dataset.locked = 'false';
      display.appendChild(span);
      chars.push(span);
    }

    // Add cursor
    const cursor = document.createElement('span');
    cursor.className = 'cursor';
    display.appendChild(cursor);

    return chars;
  }

  function cycleRandomChars(chars) {
    chars.forEach(span => {
      if (span.dataset.locked === 'false') {
        span.textContent = getRandomChar();
      }
    });
  }

  function decodeWord(word) {
    return new Promise(resolve => {
      const chars = createCharSpans(word);

      // Start cycling random characters
      const cycleInterval = setInterval(() => {
        cycleRandomChars(chars);
      }, cycleSpeed);

      // Generate random order for locking characters
      const indices = [...Array(chars.length).keys()];
      for (let i = indices.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [indices[i], indices[j]] = [indices[j], indices[i]];
      }

      // Lock characters one by one
      let lockIndex = 0;
      const lockInterval = setInterval(() => {
        if (lockIndex >= indices.length) {
          clearInterval(lockInterval);
          clearInterval(cycleInterval);
          resolve();
          return;
        }

        const charIndex = indices[lockIndex];
        const span = chars[charIndex];
        span.textContent = span.dataset.target;
        span.dataset.locked = 'true';
        span.classList.remove('scrambling');
        span.classList.add('locked');
        lockIndex++;
      }, decodeSpeed);
    });
  }

  function scrambleOut() {
    return new Promise(resolve => {
      const chars = Array.from(display.querySelectorAll('.char'));

      // Generate random order for unlocking
      const indices = [...Array(chars.length).keys()];
      for (let i = indices.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [indices[i], indices[j]] = [indices[j], indices[i]];
      }

      // Start cycling for unlocked chars
      const cycleInterval = setInterval(() => {
        chars.forEach(span => {
          if (span.dataset.locked === 'false') {
            span.textContent = getRandomChar();
          }
        });
      }, cycleSpeed);

      // Unlock characters one by one
      let unlockIndex = 0;
      const unlockInterval = setInterval(() => {
        if (unlockIndex >= indices.length) {
          clearInterval(unlockInterval);
          clearInterval(cycleInterval);
          resolve();
          return;
        }

        const charIndex = indices[unlockIndex];
        const span = chars[charIndex];
        span.dataset.locked = 'false';
        span.classList.remove('locked');
        span.classList.add('scrambling');
        span.textContent = getRandomChar();
        unlockIndex++;
      }, scrambleOutSpeed);
    });
  }

  async function animateWord(word) {
    isAnimating = true;

    // Decode the word
    await decodeWord(word);

    // Hold the decoded word
    await new Promise(r => setTimeout(r, holdTime));

    // Scramble out
    await scrambleOut();

    // Small pause before next word
    await new Promise(r => setTimeout(r, 100));

    isAnimating = false;
  }

  async function run() {
    while (true) {
      await animateWord(words[currentWordIndex]);
      currentWordIndex = (currentWordIndex + 1) % words.length;
    }
  }

  // Start the animation
  run();
</script>

</body>
</html>
